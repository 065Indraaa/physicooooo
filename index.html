<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<title>Ultra-Fast + Parallel Balance</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
body {
  font-family: ui-monospace, monospace;
  padding: 20px;
  max-width: 1000px;
  margin: auto;
  background: #f9f9f9;
}
label {
  display: block;
  margin: 12px 0 6px 0;
  font-weight: 500;
}
input, button, select {
  font-size: 16px;
  padding: 8px 10px;
  margin: 4px 0;
  border-radius: 4px;
  border: 1px solid #ccc;
}
#output {
  white-space: pre;
  border: 1px solid #bbb;
  padding: 12px;
  height: 60vh;
  overflow: auto;
  font-size: 14px;
  background: #fff;
}
.hit {
  background: #d4ffd4;
  font-weight: bold;
}
#status {
  font-weight: 600;
  margin: 10px 4px;
}
button {
  cursor: pointer;
  margin-right: 6px;
}
</style>
</head>
<body>
<h2>Ultra-Fast HEX → Pubkey + Parallel Balance</h2>

<label>Start HEX (64):
  <input id="startHex" size="70" value="0000000000000000000000000000000000000000000000000000000000000001">
</label>
<label>End HEX (64):
  <input id="endHex" size="70" value="fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036411c">
</label>
<label>Batch size:
  <input id="batchSize" type="number" min="1" max="1000000" value="10000" style="width:120px">
</label>
<label>Yield every N keys:
  <input id="yieldEvery" type="number" min="8" max="65536" value="1024" style="width:120px">
</label>
<label>RPC endpoint:
  <input id="rpcUrl" size="70" value="https://api.mainnet-beta.solana.com">
</label>
<label>Parallel RPC fetch limit:
  <input id="rpcParallel" type="number" min="1" max="200" value="50" style="width:120px">
</label>

<div>
  <button id="startBtn">Start Ultra-Fast Scan</button>
  <button id="stopBtn" disabled>Stop</button>
</div>

<label>Target Base58:
  <input id="targetPub" size="80" placeholder="paste pubkey target">
</label>

<label>Search by Balance ≥ :
  <input id="balanceMin" type="number" value="0" style="width:120px">
  <button id="searchBalanceBtn">Search</button>
</label>

<div id="status">Ready</div>
<div id="output"></div>

<script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
<script>
const ALPHABET="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function encodeBase58(buffer){let digits=[0];for(let i=0;i<buffer.length;i++){let carry=buffer[i];for(let j=0;j<digits.length;j++){carry+=digits[j]<<8;digits[j]=carry%58;carry=(carry/58)|0;}while(carry>0){digits.push(carry%58);carry=(carry/58)|0;}}for(let k=0;k<buffer.length&&buffer[k]===0;k++)digits.push(0);return digits.reverse().map(d=>ALPHABET[d]).join('');}
function normalizeHex(hex){hex=String(hex).trim().toLowerCase(); if(hex.startsWith("0x")) hex=hex.slice(2); if(!/^[0-9a-f]*$/.test(hex)) throw new Error("Invalid hex"); if(hex.length>64) throw new Error("Hex too long"); return hex.padStart(64,'0');}
function hexToBigInt(hex){if(hex.startsWith("0x")) hex=hex.slice(2); return BigInt("0x"+hex);}
function bigIntToHex(bi){let h=bi.toString(16); if(h.length%2) h="0"+h; return h.padStart(64,'0');}
function hexToUint8Array(hex){if(hex.startsWith("0x")) hex=hex.slice(2); if(hex.length%2) hex="0"+hex; const u=new Uint8Array(hex.length/2); for(let i=0;i<u.length;i++) u[i]=parseInt(hex.substr(i*2,2),16); return u;}
function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
function escapeHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}

const pubToSeed=new Map();
const pubToBalance=new Map();
let scanning=false,stopRequested=false,currentStartBigInt=null,endBigInt=null;

const outputEl=document.getElementById('output');
const statusEl=document.getElementById('status');
function log(s){outputEl.textContent+=s+"\n"; outputEl.scrollTop=outputEl.scrollHeight;}
function clearOutput(){outputEl.textContent="";}

function highlightPubkey(pub){const idx=outputEl.textContent.indexOf(pub);if(idx===-1)return;const before=outputEl.textContent.slice(0,idx);const match=pub;const after=outputEl.textContent.slice(idx+pub.length);outputEl.innerHTML=escapeHtml(before)+'<span class="hit">'+escapeHtml(match)+'</span>'+escapeHtml(after);}

async function rpcPost(url,body,timeoutMs=20000){const controller=new AbortController(); const id=setTimeout(()=>controller.abort(),timeoutMs); try{const res=await fetch(url,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(body),signal:controller.signal}); clearTimeout(id); return await res.json();}catch(e){clearTimeout(id); throw e;}}
async function getBalanceRpc(rpcUrl,pubkey){const body={jsonrpc:"2.0",id:1,method:"getBalance",params:[pubkey]}; const r=await rpcPost(rpcUrl,body); if(r && r.result && typeof r.result.value!=="undefined") return r.result.value; return null;}

async function ultraFastWithBalance(batchSize,yieldEvery,parallelLimit,targetPub){
  let rpcUrl=document.getElementById('rpcUrl').value.trim();
  let batchCounter=0;
  while(currentStartBigInt<=endBigInt && !stopRequested){
    batchCounter++;
    statusEl.textContent=`Batch #${batchCounter} start: ${bigIntToHex(currentStartBigInt)}`;
    const promises=[];
    for(let i=0n;i<BigInt(batchSize);i++){
      const val=currentStartBigInt+i;
      if(val>endBigInt) break;
      const seedHex=bigIntToHex(val);
      const seedBytes=hexToUint8Array(seedHex);
      const kp=nacl.sign.keyPair.fromSeed(seedBytes);
      const pub58=encodeBase58(kp.publicKey);
      pubToSeed.set(pub58,seedHex);
      log(`${seedHex} → ${pub58}`);
      if(pub58===targetPub){statusEl.textContent=`FOUND ✅ ${seedHex} → ${pub58}`; highlightPubkey(pub58); stopRequested=true; break;}
      // queue balance fetch
      const fetchPromise=(async()=>{
        try{const bal=await getBalanceRpc(rpcUrl,pub58); pubToBalance.set(pub58,bal);}catch(e){pubToBalance.set(pub58,null);}
      })();
      promises.push(fetchPromise);
      if(promises.length>=parallelLimit){await Promise.all(promises); promises.length=0;}
      if((i+1n)%BigInt(yieldEvery)===0n) await sleep(0);
      if(stopRequested) break;
    }
    if(promises.length>0) await Promise.all(promises);
    currentStartBigInt+=BigInt(batchSize);
    await sleep(1);
  }
  if(!stopRequested) statusEl.textContent="Ultra-Fast + Parallel Balance scan done.";
  scanning=false; stopRequested=false;
  document.getElementById('startBtn').disabled=false;
  document.getElementById('stopBtn').disabled=true;
}

document.getElementById('startBtn').onclick=()=>{
  if(scanning) return;
  clearOutput(); scanning=true; stopRequested=false;
  document.getElementById('startBtn').disabled=true;
  document.getElementById('stopBtn').disabled=false;
  const startHex=normalizeHex(document.getElementById('startHex').value);
  const endHexLocal=normalizeHex(document.getElementById('endHex').value);
  currentStartBigInt=hexToBigInt(startHex);
  endBigInt=hexToBigInt(endHexLocal);
  const batchSize=Math.min(1000000,Math.max(1,parseInt(document.getElementById('batchSize').value)||10000));
  const yieldEvery=Math.max(8,parseInt(document.getElementById('yieldEvery').value)||1024);
  const parallelLimit=Math.max(1,parseInt(document.getElementById('rpcParallel').value)||50);
  const targetPub=document.getElementById('targetPub').value.trim();
  ultraFastWithBalance(batchSize,yieldEvery,parallelLimit,targetPub);
};

document.getElementById('stopBtn').onclick=()=>{stopRequested=true; statusEl.textContent="Stop requested...";};

document.getElementById('searchBalanceBtn').onclick=()=>{
  const minBal=parseInt(document.getElementById('balanceMin').value)||0;
  if(!pubToSeed.size){alert("Cache kosong. Jalankan scan dulu."); return;}
  clearOutput();
  for(const [pub58,seedHex] of pubToSeed){
    const bal=pubToBalance.get(pub58);
    if(bal!==null && bal>=minBal) log(`${seedHex} → ${pub58} | Balance: ${bal}`);
  }
  statusEl.textContent=`Search by balance ≥ ${minBal} done.`;
};
</script>
</body>
</html>
